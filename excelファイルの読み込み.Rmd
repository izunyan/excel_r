
```{r eval=FALSE, include=FALSE}
#メモ用チャンク

# (PART) excelファイルを読み込む {-#readingexcel}
これはhtml用

```


# 一つのexcelファイルを読み込む

* excelファイルを読みこむには、`readxl`パッケージを使います。
* dataフォルダ（`data/`で表現）に入っている「ペンギン.xlsx」を開きます。
* `read_xlsx()`関数を使います。したがって、以下すべてファイル形式は`.xlsx`を想定します。
  + `read_xls()`や`read_excel()`もあるので、用途によって使い分けられます。ファイル形式が混ざっている時は`read_excel()`が有用かもしれません。

```{r}
library(readxl)

df <- 
 read_xlsx("data/ペンギン.xlsx") # excelファイルの読み込み

df # データの表示 
``` 

上記コードを実行すると、RStudioの右上（デフォルトの配置であれば）のEnvironmentタブに、

`df  344 obs. of 9 variables`

という表示が出ると思います。つまり、344行のデータと9列の変数が入っているデータを、オブジェクト`df`としてRに読みこんだ、ということを示しています。`df <-`の部分がその作業に該当します。

オブジェクト名である`df`と打つことで、デフォルトでは最初の10行分のデータが表示されます。ここでは紙面の都合で設定を変えているので5つだけにしています。表示された最初の行にも、`A tibble: 344 x 9`と、行数x列数の情報が出ています。表示しきれなかった行は、`with 339 more rows`と省略され、表示しきれなかった列は、`body_mass_g <dbl>, sex <chr>, year <dbl>`と、名前と<型名>が表示されます。

## 最高な機能だよ！パスの自動補完

 * `read_xlsx("")`と打った後に、`" "`の中にカーソルを置いて、tabキーを押すと、プロジェクトの中身が一覧で表示されるので、選んでいくだけで目的のファイルがキーボードを打つことなしに選べます！
   + RStudioは`" "`と打てばどこでもこの補完が可能です

*  上の階層のフォルダに行きたいときは、`" "`の中に`../`と打てば可能です。その後にtabキーを押せば上の階層のフォルダが選べます。


## 列名がひどい場合の読み込み
```{r}
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx")
```

読めることは読めますが、今後のデータ処理を進めるうえで不安が残ります。

### スペースや記号などを自動的に変換してくれる関数できれいに

`janitor`パッケージの`clean_names()`関数を使って、列名に入り込んでいるスペースや記号などを安全な記号に変換します。

なお、日本語の列名では、引数に`case = "old_janitor"`をつけないと読みにくい結果になります。


```{r}
library(tidyverse)
library(janitor)

read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  clean_names(case = "old_janitor")
```


さて、ここで使われている `%>%` は非常に大事なので解説しておきます。

#### %>% とは？ {#pipe}

「パイプ」と読みます。処理を重ねてコードに書いていきたい際に重宝し、現代の`tidyverse`を使ったRのコードに欠かせないものです。

たとえば、dfのspecies列を選択する、という処理の

```{r eval = FALSE}
select(df, species)
```

は

```{r eval = FALSE}
df %>% select(species)
```


と書けます。 `%>%`の左側にあるものを右側の最初の部分（第1引数）に渡すという働きです。パイプの利点は、いくつもつないで書いていけることです。たとえば、種類別にクチバシの長さの平均値を出したいときには次のようにできます。

```{r}
df %>% 
  group_by(species) %>% 
  summarise(平均値 = mean(bill_length_mm, na.rm = TRUE))
```

以下では`%>%`を多用していきます。

なお、ショートカット`ctrl + shit + M`（Macだと`	Cmd + Shift + M`）で出せます。


### 全角←→半角を自動で

`stringi`パッケージの`stri_trans_nfkc()`関数を使って、変数名で全角-半角のばらつきを統一させます。


ここでは、変数名をリネームするのに`rename_with()`関数を使いました。すべての変数に対し、全角文字を含んでいたら半角に直すというコードになります。

```{r}
library(stringi)
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  rename_with(~stri_trans_nfkc(.),
              everything())
```

### 上記の合わせ技

`%>%` でつなぎ合わせて1つの実行で合わせてしまうこともできます。

```{r}
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  rename_with(~stri_trans_nfkc(.),
              everything()) %>% 
    clean_names(case = "old_janitor")

```

## 開始行を指定して読みこむ
```{r}
read_xlsx("data/ペンギン（3行空き）.xlsx")
```

```{r}
read_xlsx("data/ペンギン（3行空き）.xlsx", skip = 3)
```


# シートを指定して読みこむ
## シート名の確認

`readxl`パッケージの`excel_sheets()`関数でシート名の一覧を取得できます。

```{r}
excel_sheets("data/ペンギン（シート別）.xlsx")
```

## 普通の読み込み
```{r}
read_xlsx("data/ペンギン（シート別）.xlsx")
```

デフォルトでは一番最初のシートのデータが読みこまれます。ここでは、シート「アデリー」が読み込まれました。


## シートを指定した読み込み

引数の`sheet =`にシート名を指定することで読み込めます。 

```{r}
read_excel("data/ペンギン（シート別）.xlsx", sheet = "ジェンツー" )
```



## すべてのシートから読み込み {#dflist}

ここで一気にレベルが上がりますが、これこそがRを使ってexcelファイルを読みこむ便利な部分なので、その魅力をみていきましょう。

```{r}
path_name <- "data/ペンギン（シート別）.xlsx" # データのパスを格納

# シート名を取得しそれぞれから読み込んでリストにまとめる
df_list <-
  excel_sheets(path_name) %>%                     
  set_names() %>%           # 名前付きベクトルにする
  map(read_excel, path =  path_name)

df_list # 作成したリストの表示
```
 
それぞれのexcelシートから読みこまれた3つのデータ（アデリー、ジェンツー、ヒゲ）はデータフレームとして、`df_list`にリストとしてまとめて格納されています。リストは最初は理解が難しいですが、慣れるとなんでもリストにしたくなるくらい便利なものです。リストの中身を個別に取り出してみてみましょう

```{r}
df_list$ジェンツー
```

これは、`df_list`というリストの中の、`ジェンツー`という要素（ここではデータフレーム）を取り出す、というコードです。`$`が「（左側にくるオブジェクト）の中の」という意味を表しています。自分でコードを打つと、`df_list$`と打った時点で、中の要素の一覧が表示されるはずなので、そこからクリックして選ぶこともできます。

それでは、先ほど実行した読み込みコードの解説をします。

```{r eval = FALSE}
path_name <- "data/ペンギン（シート別）.xlsx"
```

これは、単にファイルの場所を`path_name`に格納しただけです。自分のデータで試してみたいときは、基本的にここのパス名を変えるだけで実行できるはずです。

```{r eval = FALSE}
df_list <-
  excel_sheets(path_name) %>%                    
  set_names() %>%                           
  map(read_excel, path =  path_name) 
```

`excel_sheets()`は上で実行したのと同じです。実行結果はベクトルとして保存されています。`set_names()`は、ベクトルを名前付きベクトルにする働きをします。なので、ここでできるのは、

```{r}
excel_sheets(path_name) %>%                    
  set_names()
```

です。それぞれについて`purrr`パッケージの`map()`関数を使って`read_excel()`を1つ1つのシート（ここでは作成した名前付きベクトルの要素）に適用していき、データを読み込みデータフレームにし、1つのリストにまとめるという作業をします。


```{r eval=FALSE, include=FALSE}
# clean_names()も組み合わせる
df_list <-
  excel_sheets(path_name) %>%                    
  set_names() %>%                           
  map(read_excel, path =  path_name) %>%
  map(clean_names, case = "old_janitor")    # 列名をきれいに
```



### 一つのデータフレームにする {#onedflist}

`bind_rows()`は、データフレームを縦に連結します。データフレームがリストになったものが引数にくると、それらをすべて縦につなげてくれます。引数`.id =`で、リストの要素名を変数の値として入れることができるので、どのデータフレームから来たのか識別することが可能になります。ここでは`group`という名前にしています。

```{r}
df_all <- 
bind_rows(df_list, .id = "group")

```

#### 作成したデータフレームの確認

`slice()`関数を使って、最初の3行と最後の3行だけを表示してどんなものができたか確認します。`1:3`は1行目から3行目、`(n()-2):n()`は、列数（ただし現在のgroup内）を表す`n()`とそれから-2行した`(n()-2)`で表されています。

```{r}
df_all %>% 
  slice(1:3, (n()-2):n())
```

それぞれ、別々に出したほうが分かりやすいかもしれません。

```{r}
# 最初の3行
df_all %>% slice_head(n = 3)
```

```{r}
# 最後の3行
df_all %>% slice_tail(n = 3)
```


# 複数のexcelファイルを読み込む
## 読み込むファイル名の一覧のオブジェクト作成

まず、読みこみたいファイルが格納されているフォルダのファイル名、およびパス名の一覧を取得します。

```{r}
files <-
    list.files(path = "data/複数/", full.names = TRUE)

files
```


`list.files()`関数は、`path = `で指定したフォルダ内の情報を取得します。`full.names = TRUE`でパスも含めます。これをつけないと、ファイル名と拡張子だけの取得になります。

## ファイルを一括で読み込む
```{r}
ldata <-
    map(files, ~read_xlsx(.))
```

ここでできた`ldata`は、\@ref(dflist)で作成した`df_list`と同じ構造です。違いはそれぞれのデータフレームの要素名（アデリー、ジェンツー、ヒゲ）が入っていない点です。これは不便なので、以下で要素名を改めてつけます。


### ファイル名抽出

先ほど作成した`files`から、ファイル名部分だけに加工します。`str_replace()`は、`stringr`パッケージの、文字の置換をする関数です。ここでは、拡張子とパス名をそれぞれ`""`、つまり空白に置換しています。

```{r}
file_name <- 
  str_replace(files, ".xlsx", "") %>% 
  str_replace("data/複数/", "")

file_name
```

### リストの要素名にファイル名を付与
```{r}
ldata <-
    set_names(ldata, file_name)

ldata
```

```{r  eval=FALSE, include=FALSE}
# 読みこんだデータ全体のリスト構造を表示
str(ldata,
    width = 80,   # 幅の指定
    vec.len = 2,  # 行数
    list.len = 3) # 列数
```

これらを1つのデータフレームにまとめるには、 \@ref(onedflist)と同じ手順でできます。


```{r eval = FALSE}
bind_rows(ldata, .id = "group")
```