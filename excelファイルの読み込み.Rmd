
```{r eval=FALSE, include=FALSE}
#メモ用チャンク

# (PART) Excelファイルを読み込む {-#readingexcel}
これはhtml用

```


# Excelファイルの読み込み {#readexcel}
## 一つのExcelファイルを読み込む {#readoneexcel}

### ファイルの準備と読み込み  {#junbiyomikomi}
ExcelファイルをRに読み込むには、`readxl`パッケージが便利です。^[以下、まだインストールしていないパッケージがあれば、`install.packages("")`の`""`中にパッケージ名を入れて実行するか、RStudioの`Packages`タブの`Install`からインストールしてください]セクション\@ref(projecttoha)で述べた通り、ここからは、githubレポジトリのhttps://github.com/izunyan/excel_r をダウンロードしてプロジェクトを開いて進めてみてください。dataフォルダ（`data/`で表現）に入っている「ペンギン.xlsx」^[Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago
  (Antarctica) penguin data. R package version 0.1.0.
  https://allisonhorst.github.io/palmerpenguins/]を読み込んでみましょう。

読み込みには`read_xlsx()`関数を使います。したがって、以下すべてExcelファイル形式は`.xlsx`を想定します。`read_xls()`や`read_excel()`という関数もあるので、ファイル形式によって使い分けられます。ファイル形式が混ざっている時は`read_excel()`が有用かもしれません。

```{r}
library(readxl)

df <- 
 read_xlsx("data/ペンギン.xlsx") # Excelファイルの読み込み

df # データの表示 
``` 

上記コードを実行すると、RStudioの右上（デフォルトの配置であれば）のEnvironmentタブに、

```
df  344 obs. of 9 variables
```

という表示が出ると思います。つまり、344行のデータと9列の変数が入っているデータを、`df`という名前のもの（オブジェクト）としてRに読みこんだ、ということを示しています。`df <-`の部分がその作業に該当します。`<-`の右側の内容を左側のオブジェクトに格納するという意味です。ここで読み込まれた形がデータフレーム（[はじめに>本書の構成](#structure)の注参照）です。

オブジェクト名である`df`と打つことで、デフォルトでは最初の10行分のデータが表示されます。ここでは紙面の都合で設定を変えているので3行だけにしています。表示された最初の行にも、`A tibble: 344 x 9`と、行数x列数の情報が出ています。表示しきれなかった行は、`with 341 more rows`と省略され、表示しきれなかった列は、`flipper_length_mm <dbl>, body_mass_g <dbl>, sex <chr>, year <dbl>`と、`名前<データの型名>`が表示されます。なお、読みこんだファイルの保存については\@ref(writeoneexcel)章で解説します。

#### 最高な機能だよ！パスの自動補完  {#hokan}
`read_xlsx("")`と打った後に、`" "`の中にカーソルを置いて、tabキーを押すと、プロジェクトの中身が一覧で表示されるので、選んでいくだけで目的のファイルがキーボードを打つことなしに選べます！RStudioは`" "`と打てばどこでもこの補完が可能です。^[ただし、R version 4.0で文字コード関連の挙動が変わったみたいで、R 4.0.2ではエラーになりました…（未解決）]

上の階層のフォルダに行きたいときは、`" "`の中に`../`と打てば可能です。その後にtabキーを押せば上の階層のフォルダが選べます。


### 列名（変数名）がひどい場合の読み込み
```{r}
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx")
```

読めることは読めますが、今後のデータ処理を進めるうえで不安が残ります。

#### スペースや記号などを自動的に変換してくれる関数できれいに

`janitor`パッケージの`clean_names()`関数を使って、列名に入り込んでいるスペースや記号などを安全な記号に変換します。

なお、日本語の列名では、`clean_names()`関数に`case = "old_janitor"`をつけないと読みにくい結果になります。このように、関数の中に追加する情報のことを引数（ひきすう）と言います。引数によってさまざまな条件を変更することが可能になります。

```{r eval = FALSE}
library(tidyverse)
    # ↑は普通まず最初に読み込むパッケージですが、本書ではここで初めて使います
library(janitor)
```


```{r}
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  clean_names(case = "old_janitor")
```


さて、ここで使われている `%>%` は非常に大事なので解説しておきます。

#### %>% とは？ {#pipe}  
  
「パイプ」と読みます。処理を重ねてコードに書いていきたい際に重宝し、現代の`tidyverse`を使ったRのコードに欠かせないものです。たとえば、データフレームdfのspecies列を選択する、という処理の

```{r eval = FALSE}
select(df, species)
```

は

```{r eval = FALSE}
df %>% select(species)
```


と書けます。 `%>%`の左側にあるものを右側の最初の部分（第1引数）に渡すという働きです。パイプの利点は、いくつもつないで書いていけることです。たとえば、ペンギンの種類別にクチバシの長さの平均値を出したいときには次のようにできます。

```{r}
df %>% 
  group_by(species) %>% 
  summarise(平均値 = mean(bill_length_mm, na.rm = TRUE))
                              
```

以下では`%>%`を多用していきます。

なお、ショートカット`ctrl + shit + M`（Macだと`	Cmd + Shift + M`）で出せます。


#### 全角←→半角を自動で

`stringi`パッケージの`stri_trans_nfkc()`関数を使って、変数名で全角-半角のばらつきを統一させます。


ここでは、変数名をリネームするのに`dplyr 1.0.0`で登場した`rename_with()`関数を使いました。`everything()`という引数を含めているので、すべての変数に対し、全角文字を含んでいたら半角に直すというコードになります。

```{r}
library(stringi)
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  rename_with(~stri_trans_nfkc(.),
              everything())
```

\newpage

#### 上記の合わせ技

`%>%` でつなぎ合わせて1つの実行で合わせてしまうこともできます。

```{r}
read_xlsx("data/ペンギン（ひどい列名）ver.xlsx") %>% 
  rename_with(~stri_trans_nfkc(.),
              everything()) %>% 
    clean_names(case = "old_janitor")

```

### 開始行を指定して読み込む

理想的なデータは1行目に列名が入力されている形ですが、最初の数行が空だったり、文字の説明が入っていたりすることも多いです。そうした場合は、以下のような読み込み結果になります。

```{r}
read_xlsx("data/ペンギン（3行空き）.xlsx") %>% 
  select(1:3) # 紙面の都合のため最初の3列に制限
```

列名が、セルに内容が入っている行から始まり、他の列名が`...1`, `...3`といったものになりました。そしてデータがうまく読み込めていません。これを、指定した行から読み込むには、引数`skip =`にとばしたい行の数を指定します。

```{r}
read_xlsx("data/ペンギン（3行空き）.xlsx", skip = 3)
```

このように、ちゃんと読む込むことができました。


### セルを指定して読み込む

引数`range =`にセル範囲を指定すれば、そのセル範囲だけを読み込むこともできます。

```{r}
read_xlsx("data/ペンギン.xlsx", range = "A1:D5")
```

他にも、`cell_cols =`で読みたい列の指定、`cell_rows =`で読みたい行の指定も行えます。

詳細は、`?readxl`と打ち込んでヘルプを見るか、readxlの[webサイト](https://readxl.tidyverse.org/) ^[https://readxl.tidyverse.org/]を参照してください。


## シートを指定して読み込む
### シート名の確認
複雑なExcelファイルとなると、たくさんのシートが含まれていて、その全容を知るのも一苦労です。Rでは、`readxl`パッケージの`excel_sheets()`関数でシート名の一覧を簡単に取得できます。

```{r}
excel_sheets("data/ペンギン（シート別）.xlsx")
```

### 普通の読み込み

シートが分かれているExcelファイルをそのまま読みこんでみます。

```{r}
read_xlsx("data/ペンギン（シート別）.xlsx")
```

デフォルトでは一番最初のシートのデータが読みこまれます。ここでは、シート「アデリー」が読み込まれました。


### シートを指定した読み込み

引数の`sheet =`にシート名を指定することで読み込めます。 

```{r}
read_excel("data/ペンギン（シート別）.xlsx", sheet = "ジェンツー" )
```



### すべてのシートから一気に読み込み {#dflist}

今まで身につけた知識を使うと、すべてのシートからデータを読みたいときは、単純に

```{r eval = FALSE}
df_Adelie <- 
  read_excel("data/ペンギン（シート別）.xlsx", sheet = "アデリー" )
df_Gentoo <- 
  read_excel("data/ペンギン（シート別）.xlsx", sheet = "ジェンツー" )
df_Chinstrap <- 
  read_excel("data/ペンギン（シート別）.xlsx", sheet = "ヒゲ" )
```

と１つずつ読み込めばよいとわかります。しかし、これが100シート分あったら読むだけで多くの時間がかかり、うんざりしてしまうでしょう。また、疲労によりミスも起こるかもしれません。コードも長くて読みにくくなってしまいます。そんな時に**便利で正確で短くコードが書ける**素敵な方法があるのです。おそらくこれを知って使えるようになることが、初心者から中級者への第一歩になるのではないでしょうか。

ここで**一気にレベルが上がり**ますが、これこそがRを使ってExcelファイルを読み込む便利な部分（その用途に限らず、コード書いてコンピュータに働いてもらうの最高！ってなる部分）なので、その魅力をみていきましょう。

```{r}
path_name <- "data/ペンギン（シート別）.xlsx" # データのパスを格納

# シート名を取得しそれぞれから読み込んでリストにまとめる
df_list <-
  excel_sheets(path_name) %>%                     
  set_names() %>%           # 名前付きベクトルにする
  map(read_excel, path =  path_name)

df_list # 作成したリストの表示
```
 
それぞれのExcelシートから読みこまれた3つのデータ（アデリー、ジェンツー、ヒゲ）はデータフレームとして、`df_list`にリストと呼ばれる形式にてまとめて格納されています。リストは最初は理解が難しいですが、慣れるとなんでもリストにしたくなるくらい便利なものです。リストの中身を個別に取り出してみてみましょう。

```{r}
df_list$ジェンツー
```

これは、`df_list`というリストの中の、`ジェンツー`という要素（ここではデータフレーム）を取り出す、というコードです。`$`が「（左側にくるオブジェクト）の中の」という意味を表しています。自分でコードを打つと、`df_list$`と打った時点で、中の要素の一覧が表示されるはずなので、そこからクリックして選ぶこともできます。

それでは、先ほど実行した読み込みコードの解説をします。

```{r eval = FALSE}
path_name <- "data/ペンギン（シート別）.xlsx"
```

これは、単にファイルの場所を`path_name`に格納しただけです。自分のデータで試してみたいときは、基本的にここのパス名を変えるだけで実行できるはずです。

```{r eval = FALSE}
df_list <-
  excel_sheets(path_name) %>%                    
  set_names() %>%                           
  map(read_excel, path =  path_name) 
```

`excel_sheets()`は上で実行したのと同じです。実行結果はベクトルとして保存されています。`set_names()`は、ベクトルを名前付きベクトルにする働きをします。なので、ここでできるのは、

```{r}
excel_sheets(path_name) %>%                    
  set_names()
```

です。  

それぞれについて`purrr`パッケージの`map()`関数を使って`read_excel()`を1つ1つのシート（ここでは作成した名前付きベクトルの要素）に適用していき、データを読み込みデータフレームにし、1つのリストにまとめるという作業をします。繰り返し似たような作業をするときに、この`map()`関数が非常に便利です。


```{r eval=FALSE, include=FALSE}
# clean_names()も組み合わせる
df_list <-
  excel_sheets(path_name) %>%                    
  set_names() %>%                           
  map(read_excel, path =  path_name) %>%
  map(clean_names, case = "old_janitor")    # 列名をきれいに
```


#### 一つのデータフレームにする {#onedflist}

`bind_rows()`は、データフレームを縦に連結します。データフレームがリストになったものが引数にくると、それらをすべて縦につなげてくれます。引数`.id =`で、リストの要素名を変数の値として入れることができるので、どのデータフレームから来たのか識別することが可能になります。ここでは`group`という名前にしています。

```{r}
df_all <- 
  bind_rows(df_list, .id = "group")

```

#### 作成したデータフレームの確認

最初の3行と最後の3行だけを表示してどんなものができたか確認します。`dplyr`パッケージの`slice_head()`, `slice_tail()`関数を使って、引数`n =`に表示したい行数を指定することで、最初および最後の数行を取得できます。

```{r}
# 最初の3行
df_all %>% slice_head(n = 3)
```

```{r}
# 最後の3行
df_all %>% slice_tail(n = 3)
```


一気にやるには`slice()`関数が便利です。`1:3`は1行目から3行目、`(n()-2):n()`は、列数（ただし現在のgroup内）を表す`n()`とそれから-2行した`(n()-2)`で表されています。

```{r}
df_all %>% 
  slice(1:3, (n()-2):n())
```

\newpage

## 複数のExcelファイルを読み込む {#readseveralexcel}

それでは、さらにRの恩恵を深く実感できる部分に入ります。読みこみたいExcelファイルが大量にある場合です。これも実務上よく遭遇します。やり方としては、\@ref(dflist)で使った方法とほぼ同じです。

ただし、ここでは読み込むファイルの構造がすべて同様の場合に限ります。残念ながら、それがかなわない状況に、現実ではたくさん遭遇します。いつか本書の応用編を書くことがあったら、そちらで解説することとして、今回は構造が単純な場合に限って解説します。  

おそらく、単純に思いつく方法は、

```{r eval = FALSE}
df_Adelie    <- read_xlsx("data/複数/アデリー.xlsx")
df_Gentoo    <- read_xlsx("data/複数/ジェンツー.xlsx")
df_Chinstrap <- read_xlsx("data/複数/ヒゲ.xlsx")
```

と1つずつ読んでいく方法ですが、これも大量にあったら泣きたくなる作業です。1つ1つファイル名を入力やコピペする間にいくらでもミスが生じます。\@ref(hokan)で紹介した自動補完を使っても、楽しいのは最初だけでしょう。そこで、ファイルを指定するところから極力人の手を介さず進めていく方法を次に解説していきます。


### 読み込むファイル名の一覧のオブジェクト作成

まず、読み込みたいファイルが格納されているフォルダのファイル名、およびパス名の一覧を取得します。

```{r}
files <-
    list.files(path = "data/複数/", full.names = TRUE)

files
```


`list.files()`関数は、`path = `で指定したフォルダ内の情報を取得します。`full.names = TRUE`でパスも含めます。これをつけないと、ファイル名と拡張子だけの取得になります。

このうち、使用するのはxlsxファイルだけなので、文字列で該当するデータを取得する`str_subset()`を用い、以下のように限定します。

```{r}
files <- 
  files %>% str_subset("xlsx")

files
```


### ファイルを一括で読み込む {#ikkatsuread}
```{r}
ldata <-
    map(files, ~read_xlsx(.))

ldata
```

ここでできた`ldata`は、\@ref(dflist)で作成した`df_list`と同じ構造です。違いはそれぞれのデータフレームの要素名（アデリー、ジェンツー、ヒゲ）が入っていない点です。各要素の上の部分にある名前が`[[1]], [[3]], [[3]]`と表示されています（つまり、1, 2, 3の数値が割り当てられている）。要素名が入っていないのは不便なので、以下で要素名を改めてつけます。


#### ファイル名抽出

先ほど作成した`files`から、ファイル名部分だけに加工します。`str_replace()`は、`stringr`パッケージの、文字の置換をする関数です。ここでは、拡張子とパス名をそれぞれ`""`、つまり空白に置換しています。

```{r}
file_name <- 
  str_replace(files, ".xlsx", "") %>% 
  str_replace("data/複数/", "")

file_name
```

#### リストの要素名にファイル名を付与

\@ref(dflist)で使った`set_names()`関数は、リストの要素名を付ける時にも使えます。リスト`ldata`の3つの要素に、`file_name`の中身を割り当てます。

```{r}
ldata <-
    set_names(ldata, file_name)

ldata
```

```{r  eval=FALSE, include=FALSE}
# 読みこんだデータ全体のリスト構造を表示
str(ldata,
    width = 80,   # 幅の指定
    vec.len = 2,  # 行数
    list.len = 3) # 列数
```

このように、ちゃんと要素に名前が付きました。これらを1つのデータフレームにまとめるには、 \@ref(onedflist)と同じ手順でできます。


```{r eval = FALSE}
bind_rows(ldata, .id = "group")
```

### 読み込むファイルが複数フォルダにある場合

`data/複数`フォルダの中に、さらにフォルダ1～フォルダ3がありました。この中にもそれぞれxlsxファイルが入っていて、それぞれ読み込みたいとします。その場合は、先ほど使った`list.files()`関数の引数、`recursive = TRUE`を追加します。これによって、フォルダの深い階層までもすべて読み込むことが可能になります。

```{r}
files <-
    list.files(path = "data/複数/", full.names = TRUE, recursive = TRUE)

files
```

このうち、使用するのはフォルダ1～3に入っているxlsxファイルだけなので、`str_subset()`関数で以下のように絞り込みます。ここの`""`の中に入る文字列がどうなるかが難しいところかもしれませんが、ここは正規表現という本書の範囲を超える世界なので、深入りはしません。

```{r}
files <- 
  files %>% str_subset("フォルダ")
```

あとは\@ref(ikkatsuread)と同じ手順で読み込めます。